---
layout: post
title: Code Log | Programming concepts learned in Autumn 2024
cover-img: ["assets/img/posts/Beach-Set.jpg"]
tags: [learn, ðŸ’»code]
---

## c++ naming convention with auto

In C++17 and above, it's equivelantly efficient to write the following ([link](https://stackoverflow.com/questions/39536814/c-using-auto-to-declare-classes-as-variables-inside-functions)):
```cpp
Dog obj1{args...};
auto obj2 = Dog{args...};
auto obj2 = Dog(args...); // could also do this

// also 
auto obj3 = std::make_unique<Dog>(args...);
```

Using auto always is generally more consistent. You can avoid problems with weird constructor sytnax.
You should use intellisense to view the types of variables.

## c++: returing references

You can write functions that return references. Remember to pass relevant input as simple reference (not const ref) and to use `auto&` when calling the function. 
In general, `const ref` variables are useful when just viewing an object and simple `ref` functions are used when we need to update member data of the variable. 

> Note that in the functional programming paradigm, we never update an existing object. We alwyas copy, update a field and then reassign. Functions never have side effects to inputs parameters. In the contrary, when passing by `ref` (and not `const ref`) in C++, the user can change whatever he wants, and you just trust that he operates in the correct manner (not corrupting your data, etc).

```cpp
// copy to https://godbolt.org/
#include <string>
#include <iostream>
#include <cassert>

struct Person {
    std::string name;
    int age;
};

struct Deal {
    Person buyer;
    Person seller;
    int amount;
};

Person getBuyer(const Deal& deal){
    return deal.buyer;
}

Person& getBuyerRef(Deal& deal){
    return deal.buyer;
}

int main() {
    // useful way initializing simple structs
    auto p1 = Person{
        .name = "Mike",
        .age = 22
    };

    auto dealA = Deal{
        // .buyer = Person{
        .buyer = {
            .name = "Mike",
            .age = 22
        },
        .seller  = {
            .name = "Bob",
            .age = 25
        },
        .amount = 43
    };

    auto& buyerA = getBuyerRef(dealA);
    // checking references actually are referring to same objects (not just equality)
    assert((&buyerA == &dealA.buyer)); // same Buyer object

    // see this in action
    assert((buyerA.name == dealA.buyer.name));
    buyerA.name = "Mary";
    assert((buyerA.name == dealA.buyer.name)); // both variables changed name

    const auto buyerB = getBuyer(dealA);
    assert((&buyerB != &dealA.buyer)); // different objects

    return 0;
}
```

## python acronyms

[EAFP](https://docs.python.org/3/glossary.html#term-EAFP): Easier to ask for forgiveness than permission. This coding style is assumes the existence of valid keys or attributes and catches exceptions if the assumption proves false. 
[LBYL](https://docs.python.org/3/glossary.html#term-LYBL): Look before you leap. It's the opposite of the previous coding style. This coding style explicitly tests for pre-conditions before making calls or lookups.
[REPL](https://docs.python.org/3/glossary.html#term-REPL): Read-eval-print loop. It's another name for the interactive interpreter shell. [Replit](https://replit.com/) and other tools take the name from it. Originally developed for the LISP language (the mother of functional programming) [according to wiki](https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop).


## VScode like a pro

Firstly, with `CMD + SHIFT + P` I can bring the Command Palette and search for all utilities. This is the smartest thing in VSCode.
In Command Palette type `Shortcuts` to view the provided shortcuts. 
You can also view a few cheat sheets before reading below for my personal favourties. 

* I often want to see the implementation of the function i view. In Command Palette type "Go To Implementation" (shortcut: `CMD + Click`)
* I often want to see where the function is called. In Command Palette type "Find All References" (shortcut: `CMD + SHIFT + F12` or `CMD + F12`).
* 
