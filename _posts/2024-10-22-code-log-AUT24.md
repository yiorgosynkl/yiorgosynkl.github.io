---
layout: post
title: Code Log | Programming concepts learned in Autumn 2024
cover-img: ["assets/img/posts/Beach-Set.jpg"]
tags: [learn, ðŸ’»code]
---

## lambdas: declaring them, assigning them to variables etc.

```cpp
#include <string>
#include <iostream>
#include <cassert>
#include <functional>
#include <algorithm>

int getSizeA(const std::string& s){
    return s.size();
}

// you can pass lambda functions as arguments to other functions
int getSumA(int a, const std::string& s, const std::function<int(const std::string&)>& string2num){
    return a + string2num(s);
}

// you can also have a default argument for the function
int getSumB(int a, const std::string& s, 
    const std::function<int(const std::string&)> string2num = std::function{[](const std::string& s) -> int {
        return s.size();
    }}
){
    return a + string2num(s);
}

// in C++20 and forward, you can have auto arguments in functions!!

int main() {
    std::function<int(const std::string&)> getSizeB = [](const std::string& s){
        return s.size();
    };

    // no need to declare the input parameters twice
    // you can also declare the return type with cool syntax
    auto getSizeC = [](const std::string& s) -> int {
        return s.size();
    };

    assert((4 == getSumA(1, "hey", getSizeC)));
    assert((4 == getSumB(1, "hey"))); // using the function with default lambda


    // using a different string2num conversion
    auto getAs = std::function{[](const std::string& s)-> int {
        return std::count_if( s.begin(), s.end(), []( char c ){return c =='A';});
    }};
    assert((10 == getSumB(7, "BANANA", getAs))); 

    // this shows the manual labour you need to do in C++
    // although versatile, it is not expressive out of the box and not concise when writing code


    // More notes:
    // * lambdas are anonymous, you need to assign them to a variable to reference them
    // * you can pass scope variables inside the `[]`, that can be accessed in the body of the function
    // * std::function cannot take defaults. It would be complicated to implement, without particular benefit. default parameters don't make much sense for lambdas, 
    //   as they are short lived, and used for particular reasons. 
    // * however, for a lambda argument, you can also define a default lambda (see above)

    return 0;
}
```

## c++ naming convention with auto

In C++17 and above, it's equivelantly efficient to write the following ([link](https://stackoverflow.com/questions/39536814/c-using-auto-to-declare-classes-as-variables-inside-functions)):
```cpp
Dog obj1{args...};
auto obj2 = Dog{args...};
auto obj2 = Dog(args...); // could also do this

// also 
auto obj3 = std::make_unique<Dog>(args...);
```

Using auto always is generally more consistent. You can avoid problems with weird constructor sytnax.
You should use intellisense to view the types of variables.

## c++: returing references

You can write functions that return references. Remember to pass relevant input as simple reference (not const ref) and to use `auto&` when calling the function. 
In general, `const ref` variables are useful when just viewing an object and simple `ref` functions are used when we need to update member data of the variable. 

> Note that in the functional programming paradigm, we never update an existing object. We alwyas copy, update a field and then reassign. Functions never have side effects to inputs parameters. In the contrary, when passing by `ref` (and not `const ref`) in C++, the user can change whatever he wants, and you just trust that he operates in the correct manner (not corrupting your data, etc).

```cpp
// copy to https://godbolt.org/
#include <string>
#include <iostream>
#include <cassert>

struct Person {
    std::string name;
    int age;
};

struct Deal {
    Person buyer;
    Person seller;
    int amount;
};

Person getBuyer(const Deal& deal){
    return deal.buyer;
}

Person& getBuyerRef(Deal& deal){
    return deal.buyer;
}

int main() {
    // useful way initializing simple structs
    auto p1 = Person{
        .name = "Mike",
        .age = 22
    };

    auto dealA = Deal{
        // .buyer = Person{
        .buyer = {
            .name = "Mike",
            .age = 22
        },
        .seller  = {
            .name = "Bob",
            .age = 25
        },
        .amount = 43
    };

    auto& buyerA = getBuyerRef(dealA);
    // checking references actually are referring to same objects (not just equality)
    assert((&buyerA == &dealA.buyer)); // same Buyer object

    // see this in action
    assert((buyerA.name == dealA.buyer.name));
    buyerA.name = "Mary";
    assert((buyerA.name == dealA.buyer.name)); // both variables changed name

    const auto buyerB = getBuyer(dealA);
    assert((&buyerB != &dealA.buyer)); // different objects

    return 0;
}
```

## python acronyms

[EAFP](https://docs.python.org/3/glossary.html#term-EAFP): Easier to ask for forgiveness than permission. This coding style is assumes the existence of valid keys or attributes and catches exceptions if the assumption proves false. 
[LBYL](https://docs.python.org/3/glossary.html#term-LYBL): Look before you leap. It's the opposite of the previous coding style. This coding style explicitly tests for pre-conditions before making calls or lookups.
[REPL](https://docs.python.org/3/glossary.html#term-REPL): Read-eval-print loop. It's another name for the interactive interpreter shell. [Replit](https://replit.com/) and other tools take the name from it. Originally developed for the LISP language (the mother of functional programming) [according to wiki](https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop).


## VScode like a pro

Firstly, with `CMD + SHIFT + P` I can bring the Command Palette and search for all utilities. This is the smartest thing in VSCode.
In Command Palette type `Shortcuts` to view the provided shortcuts. 
You can also view a few cheat sheets before reading below for my personal favourties. 

* I often want to see the implementation of the function i view. In Command Palette type "Go To Implementation" (shortcut: `CMD + Click`)
* I often want to see where the function is called. In Command Palette type "Find All References" (shortcut: `CMD + SHIFT + F12` or `CMD + F12`).
* 
